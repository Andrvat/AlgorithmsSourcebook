# Contents

- Сортировки
    - [Понятие сортировки. Быстрая сортировка Хоара. Оценка числа операций](#Быстрая-сортировка-Хоара)
    - [Понятие сортировки. Пирамидальная сортировка. Оценка числа операций.](#Пирамидальная-сортировка)

____

## Быстрая сортировка Хоара

Постановка проблемы: есть набор неотсортированных данных. Необходимо произвести сортировку по возрастанию/убыванию, то есть произвести упорядочивание однотипных элементов.

Отличительной особенностью быстрой сортировки является **операция разбиения массива на две части относительно опорного элемента**. Например, если последовательность требуется упорядочить по возрастанию (наш случай в разборе), то в левую часть будут помещены все элементы, значения которых меньше значения опорного элемента, а в правую элементы, чьи значения больше или равны опорному. Если длина какой-то из получившихся в результате разбиения частей превышает один элемент, то для нее нужно **рекурсивно выполнить упорядочивание**, т. е. повторно запустить алгоритм на каждом из отрезков.

**Выбор опорного элемента** не влияет на результат, и поэтому может пасть на произвольный элемент. Тем не менее, **наибольшая эффективность** алгоритма достигается при выборе опорного элемента, делящего последовательность на равные или примерно равные части.

Непосредственно **сам  алгоритм:**

1. Выбираем опорный элемент *v* - как правило, берут середину рассматриваемого отрезка
2. Разбиваем массив на 3 части:
    - Создаём переменные *i* и *j* — индексы соответственно начала и конца рассматриваемого подмассива
    - Увеличиваем *i*, пока *i*-й элемент меньше опорного
    - Уменьшаем *j*, пока *j*-й элемент больше опорного
    - Если *i* всё ещё меньше *j*, то меняем *i*-й и *j*-й элементы местами, инкрементируем *i* и декрементируем *j*
    - Если *i* вдруг становится больше либо равно *j*, то прерываем цикл
3. В конце концов, просмотры слева-направо и справа-налево сходятся в одной точке *j*, которая нам разделит рассматриваемый массив на два подмассива. Повторяем рекурсивно алгоритм уже для них, пока не дойдём до массива из 1 элемента - это контролируется условием *if l < r* в основной функции *quicksort*.

```c
int partition(int a[], int l, int r) {
    int v = a[(l + r) / 2];
    int i = l;
    int j = r;
    while (i <= j) {
        while (a[i] < v) {
            i++;
	}
        while (a[j] > v) {
            j--;
	}
        if (i >= j) {
            break;
	}
        swap(a[i++], a[j--]);
    }
    return j;
}

void quicksort(int a[], int l, int r) {
    if (l < r) {
        int q = partition(a, l, r);
        quicksort(a, l, q);
        quicksort(a, q + 1, r);
    }
}
```

Для сортировки всего массива необходимо выполнить процедуру

```c
quicksort(a, 0, length(a) − 1)
```

**Оценка сложности алгоритма**:

Каждое **разделение** требует *O(n)* операций - в силу того, что мы идем слева-направо и справа-налево, пробегая все элементы текущего отрезка. **Количество шагов** деления (глубина рекурсии) составляет приблизительно *log n*, если массив делится на более-менее равные части. Таким образом, **общее быстродействие**: *O(n log n)*, что и имеет место на практике.

**Однако, возможен случай** таких входных данных, на которых алгоритм будет работать за *O(n^2)* операций. Такое происходит, если каждый раз в качестве опорного элемента выбирается максимум или минимум входной последовательности. В таком случае у нас всё время массив длины *N* будет делиться на два подмассива длины *1* и *N - 1*.

[:arrow_up: Back to contents](#Contents)
____

## Пирамидальная сортировка

Постановка проблемы: есть набор неотсортированных данных. Необходимо произвести сортировку по возрастанию/убыванию, то есть произвести упорядочивание однотипных элементов.

**Пирамидальная сортировка** (*HeapSort*) — это метод сортировки сравнением, основанный на такой структуре данных как двоичная куча.

Сам алгоритм можно разделить на два этапа:
1. Формирование двоичной кучи.
2. Сортировка данных на основе сформированной двоичной кучи.

Перед тем, как определить понятие бинарной кучи, необходимо понять, что называют законченным бинарным деревом. Итак, **законченное бинарное дерево** - это двоичное дерево, в котором **каждый уровень, за исключением, возможно, последнего, имеет полный набор узлов, и все листья расположены как можно левее.** Пример:
![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a9a725e-8b17-4164-a23d-6bd5f49a057f/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2a9a725e-8b17-4164-a23d-6bd5f49a057f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20200809%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20200809T111132Z&X-Amz-Expires=86400&X-Amz-Signature=5a0a0da93be296ddd2387b919494f6f3a68eab45cf9806058ba55a954d92b297&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)
Теперь можно сказать, что такое **двоичная куча** — это **законченное двоичное дерево**, в котором элементы хранятся в особом порядке: **значение в родительском узле больше (или меньше) значений в его двух дочерних узлах.** Первый вариант называется max-heap, а второй — min-heap. Другими словами, выполняется условие:

```c
// Для max-heap

a[i] >= a[2 * i + 1];
a[i] >= a[2 * i + 2];

индекс i - родитель
индекс 2i + 1 - левый ребенок
индекс 2i + 2 - правый ребенок
```

Будем хранить данные в виде обычного **массива**. Именно в таком виде представления данных будет удобно работать с индексами элементов (см. в коде).
**WARNING!** Далее будет всё для случая **сортировки по возрастанию**. По убыванию - зеркальте всё, что видите.
Пусть у нас будет дан массив *arr[]*, который нужно отсортировать. Длина массива - *n*.
#### Первый шаг: построение бинарной кучи.
Нужно построить бинарную кучу. Делать мы это будем следующим образом:
1. **Смотрим на сыновей слева и справа** - в массиве это *arr[2i+1]* и *arr[2i+2]* - выбираем наибольшего из сыновей и родителя, с которого мы начинали данный шаг.
2.  Если этот элемент больше родителя *arr[i]* - **меняем** его с *arr[i]* местами и идем к шагу 1, имея в виду новое положение *arr[i]* в массиве - **будем преобразовать затронутое поддерево. Иначе конец процедуры.**

```c
void heapify(int arr[], int n, int i) {
  int largest = i;
  // Инициализируем наибольший элемент как корень
  int l = 2*i + 1; // левый 
  int r = 2*i + 2; // правый

 // Если левый дочерний элемент больше корня
  if (l < n && arr[l] > arr[largest]) {
        largest = l;
	}

  // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
  if (r < n && arr[r] > arr[largest]) {
        largest = r;
	}

  // Если самый большой элемент не корень
  if (largest != i) {
        swap(arr[i], arr[largest]);
			// Рекурсивно преобразуем в двоичную кучу затронутое поддерево
        heapify(arr, n, largest);
    }
}
```
Описанные выше два пункта выполняются для одного корня с индексом *i*, а не для всего массива. Поэтому **такую процедуру необходимо произвести с индекса (n/2) - 1 и до нуля.**

#### Второй шаг: сама пирамидальная сортировка.
На данном этапе после приведения данных к двоичной куче **самый большой элемент хранится в корне кучи** (см. главное свойство бин. кучи).
Основное тело алгоритма пирамидальной сортировки состоит из следующих пунктов:
1. **Будем менять корень кучи на последний элемент кучи, уменьшая при этом её размер на единиц**у - так мы будем отсекать те элементы, которые уже заняли нужные места и более сортировке не подлежат.
2. После такой замены **свойство бинарной кучи может нарушиться** - необходимо заново **преобразовать полученное бинарное дерево в max-heap с новым корнем**. Для этого будем вызывать ту же функцию *heapfy()*, что мы пользовались и при построении бинарной кучи (логично, не правда ли?) для корневого элемента.
3. Так будем выполнять, **пока индекс** нашей условной правой границы, которая с каждым шагом движется левее, **не станет меньше нуля** - это будет означать, что мы рассмотрели все элементы массива, значит сортировка окончена.

```c
// Основная функция, выполняющая пирамидальную сортировку
void heapSort(int arr[], int n) {
  // Построение кучи
  for (int i = n / 2 - 1; i >= 0; i--) {
      heapify(arr, n, i);
  }

 // Один за другим извлекаем элементы из кучи
  for (int i=n-1; i >= 0; i--) {
      // Перемещаем текущий корень в конец
      swap(arr[0], arr[i]);

      // вызываем процедуру heapify на уменьшенной куче
      heapify(arr, i, 0);
  }
}
```

Иллюстрация: [Click on](https://www.youtube.com/watch?v=MtQL_ll5KhQ)

**Оценка:**
Самое **главное преимущество** данного алгоритма: число итераций цикла в процедуре просеивания *heapfy()* не превосходит высоты пирамиды, а высота полного бинарного дерева из *n* узлов, каковым является пирамида, равна *log2(n)*.

Далее, просеивание имеет логарифмическую сложность. Мы в основном теле прошлись по всем элементам массива, применив к нему *heapfy()*, имеющую логарифмическую зависимость, и *swap()*, работающего за константное время - итого имеем *n * log2(n)*.

**Замечания:** несомненным достоинством является то, что **худший, средний и лучший случаи для пирамидальной сортировки совпадают.** Однако, сам является **неустойчивым**, то есть он допускает изменение относительного порядка сортируемых элементов.

[:arrow_up: Back to contents](#Contents)
____
